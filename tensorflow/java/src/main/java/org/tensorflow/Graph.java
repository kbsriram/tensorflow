/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

package org.tensorflow;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * A data flow graph representing a TensorFlow computation.
 *
 * <p>Instances of a Graph are thread-safe.
 *
 * <p><b>WARNING:</b> Resources consumed by the Graph object must be explicitly freed by invoking
 * the {@link #close()} method then the Graph object is no longer needed.
 */
public final class Graph implements AutoCloseable {

  /** Create an empty Graph. */
  public Graph() {
    nativeHandle = allocate();
  }

  /** Create a Graph from an existing handle (takes ownership). */
  Graph(long nativeHandle) {
    this.nativeHandle = nativeHandle;
  }

  /**
   * Release resources associated with the Graph.
   *
   * <p>Blocks until there are no active {@link Session} instances referring to this Graph. A Graph
   * is not usable after close returns.
   */
  @Override
  public void close() {
    synchronized (nativeHandleLock) {
      if (nativeHandle == 0) {
        return;
      }
      while (refcount > 0) {
        try {
          nativeHandleLock.wait();
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          // Possible leak of the graph in this case?
          return;
        }
      }
      delete(nativeHandle);
      nativeHandle = 0;
    }
  }

  /**
   * Returns the operation (node in the Graph) with the provided name.
   *
   * <p>Or {@code null} if no such operation exists in the Graph.
   */
  public Operation operation(String name) {
    synchronized (nativeHandleLock) {
      long oph = operation(nativeHandle, name);
      if (oph == 0) {
        return null;
      }
      return new Operation(this, oph);
    }
  }

  /**
   * Returns a builder to add {@link Operation}s to the Graph.
   *
   * @param type of the Operation (i.e., identifies the computation to be performed)
   * @param name to refer to the created Operation in the graph.
   * @return an {@link OperationBuilder}, which will add the Operation to the graph when {@link
   *     OperationBuilder#build()} is invoked. If {@link OperationBuilder#build()} is not invoked,
   *     then some resources may leak.
   */
  public OperationBuilder opBuilder(String type, String name) {
    return new OperationBuilder(this, type, name);
  }

  /**
   * Import a serialized representation of a TensorFlow graph.
   *
   * <p>The serialized representation of the graph, often referred to as a <i>GraphDef</i>, can be
   * generated by {@link #toGraphDef()} and equivalents in other language APIs.
   *
   * @throws IllegalArgumentException if graphDef is not a recognized serialization of a graph.
   * @see #importGraphDef(byte[], String)
   */
  public void importGraphDef(byte[] graphDef) throws IllegalArgumentException {
    importGraphDef(graphDef, "");
  }

  /**
   * Import a serialized representation of a TensorFlow graph.
   *
   * @param graphDef the serialized representation of a TensorFlow graph.
   * @param prefix a prefix that will be prepended to names in graphDef
   * @throws IllegalArgumentException if graphDef is not a recognized serialization of a graph.
   * @see #importGraphDef(byte[])
   */
  public void importGraphDef(byte[] graphDef, String prefix) throws IllegalArgumentException {
    if (graphDef == null || prefix == null) {
      throw new IllegalArgumentException("graphDef and prefix cannot be null");
    }
    synchronized (nativeHandleLock) {
      importGraphDef(nativeHandle, graphDef, prefix);
    }
  }

  /**
   * Generate a serialized representation of the Graph.
   *
   * @see #importGraphDef(byte[])
   * @see #importGraphDef(byte[], String)
   */
  public byte[] toGraphDef() {
    synchronized (nativeHandleLock) {
      return toGraphDef(nativeHandle);
    }
  }

  /**
   * Add operations to compute the gradient of a subgraph.
   *
   * <p>Adds operations to compute the partial derivatives of sum of <i>y</i>s w.r.t <i>x</i>s,
   * i.e., <i>d(y<sub>1</sub> + y<sub>2</sub> + ...)/dx<sub>1</sub>, d(y<sub>1</sub> + y<sub>2</sub>
   * + ...)/dx<sub>2</sub>...</i>
   *
   * <p>{@code dx} are used as initial gradients (which represent the symbolic partial derivatives
   * of some loss function <i>L</i> w.r.t. <i>y</i>).
   *
   * <p>{@code dx} must be {@code null} or have the same number of elements as {@code y}. If {@code
   * dx} is {@code null}, the implementation will effectively use {@code dx = 1} for all shapes in
   * {@code y}.
   *
   * <p>The partial derivatives are returned as a list of {@code Output}s with the same number of
   * elements as {@code x}.
   *
   * @param y is an Iterable {@code Output} pointing to the outputs of the subgraph operation of
   *     interest.
   * @param x is an Iterable {@code Output} pointing to the inputs of the subgraph operation of
   *     interest.
   * @param dx is an Iterable {@code Output} with initial gradient values. If it is null, the
   *     implementation will effectively use {@code 1} as the initial gradient for all {@code y}.
   * @return an unmodifiable List of {@code Output}s of partial derivatives.
   */
  public List<Output> addGradients(Iterable<Output> y, Iterable<Output> x, Iterable<Output> dx) {
    return Collections.unmodifiableList(
        Arrays.asList(
            addGradients(
                Util.toArray(y, Output.class),
                Util.toArray(x, Output.class),
                Util.toArray(dx, Output.class))));
  }

  private Output[] addGradients(Output[] y, Output[] x, Output[] dx) {
    synchronized (nativeHandleLock) {
      long[] yOpHandles = new long[y.length];
      int[] yOpIndices = new int[y.length];
      for (int i = 0; i < y.length; i++) {
        yOpHandles[i] = y[i].op().getUnsafeNativeHandle();
        yOpIndices[i] = y[i].index();
      }
      long[] xOpHandles = new long[x.length];
      int[] xOpIndices = new int[x.length];
      for (int i = 0; i < x.length; i++) {
        xOpHandles[i] = x[i].op().getUnsafeNativeHandle();
        xOpIndices[i] = x[i].index();
      }
      long[] dxOpHandles;
      int[] dxOpIndices;
      if (dx == null) {
        dxOpHandles = null;
        dxOpIndices = null;
      } else {
        if (dx.length != y.length) {
          throw new IllegalArgumentException(
              String.format("dx must be the same length as y (%d != %d)", dx.length, y.length));
        }
        dxOpHandles = new long[dx.length];
        dxOpIndices = new int[dx.length];
        for (int i = 0; i < dx.length; i++) {
          dxOpHandles[i] = dx[i].op().getUnsafeNativeHandle();
          dxOpIndices[i] = dx[i].index();
        }
      }
      // Native code will return handles and indices for dy in these pre-allocated
      // arrays.
      long[] dyOpHandles = new long[y.length];
      int[] dyOpIndices = new int[y.length];
      addGradients(
          nativeHandle,
          yOpHandles,
          yOpIndices,
          xOpHandles,
          xOpIndices,
          dxOpHandles,
          dxOpIndices,
          dyOpHandles,
          dyOpIndices);
      Output[] dy = new Output[y.length];
      for (int i = 0; i < dyOpHandles.length; i++) {
        Operation op = new Operation(this, dyOpHandles[i]);
        dy[i] = op.output(dyOpIndices[i]);
      }
      return dy;
    }
  }

  private final Object nativeHandleLock = new Object();
  private long nativeHandle;
  private int refcount = 0;

  // Related native objects (such as the TF_Operation object backing an Operation instance)
  // have a validity tied to that of the Graph. The handles to those native objects are not
  // valid after Graph.close() has been invoked.
  //
  // Instances of the Reference class should be used to ensure the Graph has not been closed
  // while dependent handles are in use.
  class Reference implements AutoCloseable {
    private Reference() {
      synchronized (Graph.this.nativeHandleLock) {
        active = Graph.this.nativeHandle != 0;
        if (!active) {
          throw new IllegalStateException("close() has been called on the Graph");
        }
        active = true;
        Graph.this.refcount++;
      }
    }

    @Override
    public void close() {
      synchronized (Graph.this.nativeHandleLock) {
        if (!active) {
          return;
        }
        active = false;
        if (--Graph.this.refcount == 0) {
          Graph.this.nativeHandleLock.notifyAll();
        }
      }
    }

    public long nativeHandle() {
      synchronized (Graph.this.nativeHandleLock) {
        return active ? Graph.this.nativeHandle : 0;
      }
    }

    private boolean active;
  }

  Reference ref() {
    return new Reference();
  }

  private static native long allocate();

  private static native void delete(long handle);

  private static native long operation(long handle, String name);

  private static native void importGraphDef(long handle, byte[] graphDef, String prefix)
      throws IllegalArgumentException;

  private static native byte[] toGraphDef(long handle);

  private static native void addGradients(
      long handle,
      long[] yOpHandles,
      int[] yOpIndices,
      long[] xOpHandles,
      int[] xOpIndices,
      long[] dxOpHandles,
      int[] dxOpIndices,
      long[] dyOpHandles,
      int[] dyOpIndices);

  static {
    TensorFlow.init();
  }
}
